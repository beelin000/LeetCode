//给你一个二进制字符串s。在一秒之中，所有子字符串"01" 同时被替换成"10"。这个过程持续进行到没有"01"存在。
//
//        请你返回完成这个过程所需要的秒数。
//
//
//
//        示例 1：
//
//        输入：s = "0110101"
//        输出：4
//        解释：
//        一秒后，s 变成 "1011010" 。
//        再过 1 秒后，s 变成 "1101100" 。
//        第三秒过后，s 变成 "1110100" 。
//        第四秒后，s 变成 "1111000" 。
//        此时没有 "01" 存在，整个过程花费 4 秒。
//        所以我们返回 4 。
//        示例 2：
//
//        输入：s = "11100"
//        输出：0
//        解释：
//        s 中没有 "01" 存在，整个过程花费 0 秒。
//        所以我们返回 0 。
//
//
//        提示：
//
//        1 <= s.length <= 1000
//        s[i]要么是'0'，要么是'1' 。
//
//
//        来源：力扣（LeetCode）
//        链接：https://leetcode.cn/problems/time-needed-to-rearrange-a-binary-string
//        著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
public class L2380 {
    // 直接replace替换
    public int secondsToRemoveOccurrences_1(String s) {
        int res = 0;
        while(s.indexOf("01") != -1) {
            s = s.replace("01", "10");
            res++;
        }
        return res;
    }

    public int secondsToRemoveOccurrences_2(String s) {
        /*
        动态规划:
        1.状态定义:f[i]表示考虑s[0,i]所需要的秒数
        2.状态转移:
            2.1 当s[i]==0时，其移动次数转移自前面状态
            2.2 当s[i]==1时，要保证两个下界均成立
                下界1 当前的'1'移动次数至少是前面'0'的个数
                下界2 当前的'1'移动次数至少比左侧的'1'移动次数多1(至少)
                    下界2中的多1是在遇到'11'或者'101'时候成立，此时必定是落后一位的；
                    一旦比下界2多不止1的时候，如'10001'，这时候由下界1与下界2联合保证(因为可能是0个数保证，也可能是前面堵车很多来保证)
                在两个下界中取大的值
        3.初始化:f[0]=0
        4.遍历顺序:正序
        5.返回形式:f[n-1]
        */
        int n = s.length();
        int zero = 0, f = 0;
        for (char c : s.toCharArray()) {
            if (c == '0') {
                zero++;
            } else {
                if (zero > 0) f = Math.max(f + 1, zero);
            }
        }
        return f;
    }
}
